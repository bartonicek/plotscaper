---
title: "Introduction to plotscaper"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction to plotscaper}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
bibliography: "references.bib"
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  fig.width = 6.5,
  fig.height = 4,
  comment = "#>")
```

To get started, install `plotscaper` with:

```{r}
#| eval: false
devtools::install_github("bartonicek/plotscaper")
```

Next, open up RStudio and run the following code:

```{r}
library(plotscaper)

create_schema(mtcars) |>
  add_scatterplot(c("wt", "mpg")) |>
  add_barplot("cyl") |>
  render()

```

Try clicking and dragging to select some points in the scatterplot. You should see the corresponding cases get highlighted within the barplot! 

There are many other ways interacting with `plotscaper` figures, including:

- Zooming and panning
- Changing the size of objects
- Increasing/decreasing the opacity (alpha)
- Manipulating parameters such as histogram binwidth and anchor
- Modifying axis limits and ordering discrete axes

Importantly, many of these interactions can either be done manually, by interacting with the figure (client-side), or programmatically, by calling functions from inside a running R session ("server-side"). 

## The scene and the schema

To take full advantage of `plotscaper`, you need to understand two core functions: `create_schema` and `render`. 

The `create_schema` function initializes a *schema* - a sort of a recipe which we can use to define the figure. Like in other data visualization packages, we build up the schema step-by-step, by calling functions that append additional information to it: 

```{r}
schema <- create_schema(mtcars) |> 
  add_scatterplot(c("wt", "mpg")) |> 
  add_barplot("cyl")

schema
```

Typically, you'll use the schema to add plots. However, you can also do other things such as select cases or set axis limits:

```{r}
schema |>
  select_cases(1:10) |>
  set_scale("plot1", "x", max = 12)
```

When it finally comes a time to turn the recipe into an actual interactive *scene*, we can do so by calling the `render` function:

```{r}
scene <- schema |> render()
scene
```

The `render` function takes the schema and turns it into a `htmlwidgets` widget that we can play around with in RStudio viewer or print in RMarkdown documents.

## The difference between scene and schema

However, `render` can also do more than just turn a schema into a widget. Specifically, when inside a running R session, it also launches an `httpuv` server and returns a handle to the scene.

*If you're following along in RStudio*, try this:

```{r}
#| eval: false
scene <- schema |> render()
scene
scene |> select_cases(20:30)
```

You should see that different cases get selected. However, the important thing to notice is that this happens without re-rendering the figure in the viewer!

That is, while the following code:

```{r}
#| eval: false
# NOT RUN
scene <- schema |> select_cases(20:30) |> render()
scene
scene
```

causes two full re-renders, the following code:

```{r}
#| eval: false
# NOT RUN
scene <- schema |> render()
scene |> select_cases(20:30)
scene |> select_cases(20:30)
```

causes only one render.

So the idea is that, while you can call (mostly) the same functions to interact with the scene and the schema, the way how those functions are executed is different:

- *Schema*: calling a function lazily appends to an (immutable) list of messages that will get executed in the future, when the schema is rendered
- *Scene*: calling a function immediately sends a message to the scene and mutates its state

The second method only works if we are in an interactive R session because we need a server to communicate with the figure. 

This is why, for example, running the following code (while the document you're reading is being knitted) throws an error:

```{r}
#| error: true
scene |> select_cases(1:10)
```

When we knit an RMarkdown document, we generate a static HTML file. We cannot call functions from R or any other language to communicate with this file, since it's just a big bundle of HTML, CSS, and JavaScript. To only way to change this file is to rewrite it. 

In contrast, inside an interactive R session, we can launch a server that will listen and respond to messages from the R session and send them to the figure (and also send messages from the figure back to the R session - this is done via WebSockets).

## Bonus: Scatterplot matrix

We can use the laziness of the schema to generate figures programmatically. For example, here's how we could create an interactive scatterplot matrix (SPLOM) of the `penguins` dataset [@horst2020]:

```{r}
#| fig-height: 7

library(palmerpenguins)

penguins <- na.omit(penguins[, 4:6]) # Missing data is not yet supported 
keys <- c("bill depth", "flipper length", "body mass")
names(penguins) <- keys

schema <- create_schema(penguins)

# Loop through combinations of columns
for (i in seq_along(keys)) {
  for (j in seq_along(keys)) {
    # Add a scatterplot if row & column no.'s are different
    if (i != j) schema <- schema |> add_scatterplot(c(keys[i], keys[j]))
    # Add a histogram if row & column no.'s match
    else schema <- schema |> add_histogram(c(keys[i])) 
  }
}

# Options to make the plots fit better within the available space
opts <- list(size = 5, axis_title_size = 0.75, axis_label_size = 0.5)

schema |> render(options = opts)
```

## References
